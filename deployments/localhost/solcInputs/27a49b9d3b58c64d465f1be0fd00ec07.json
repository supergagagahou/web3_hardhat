{
  "language": "Solidity",
  "sources": {
    "contracts/fundraising.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.22;\r\n\r\n/*\r\nV4.1版本：\r\n1.设置众筹目标值和众筹时间\r\n2.当众筹达到目标值时可以取出\r\n3.当在规定时间内未达到目标值时取消合约，可以退款\r\n4.管理员救币函数，强制退币\r\n5.\r\n\r\n*/\r\n\r\ncontract fundraising {\r\n    address public owner;\r\n    //发起者\r\n    uint256 public target = 10**18; //wei\r\n    //目标\r\n    uint256 public money_pool;\r\n    //资金池数量\r\n    mapping(address => uint256) investor;\r\n    //投资人地址与金额映射\r\n    address[] investor_list;\r\n    //投资人\r\n    bool private fund_is_clear = false; //合约是否被取消\r\n\r\n    uint256 start_time;\r\n    uint256 lock_time;\r\n\r\n    //众筹锁定时间，只有在锁定时间后，并且目标未达成才能取出余额\r\n\r\n    constructor(uint256 _target, uint256 _lock_time) {\r\n        //设定众筹时间和目标\r\n        owner = msg.sender;\r\n        start_time = block.timestamp;\r\n        target *= _target;\r\n        lock_time = _lock_time;\r\n    }\r\n\r\n    event fund_event(address add, uint256 money);\r\n\r\n    function fund() external payable {\r\n        //投资\r\n        require(\r\n            block.timestamp - lock_time < start_time, //是否在锁定期，非锁定时间代表已经合约结束\r\n            \"now is not lock time,It's already over. !!!\"\r\n        );\r\n        require(!finish_target(), \"finish has target!!!\"); //合约是否已经完成众筹目标\r\n        require(!fund_is_clear, \"fundraising is clear!!!\"); //合约没有被取消\r\n        require(\r\n            msg.value > 0,\r\n            \"The investment value must be greater than 0 !!!\" //投资金额要>0\r\n        );\r\n        investor[msg.sender] += msg.value;\r\n        investor_list.push(msg.sender);\r\n        money_pool += msg.value;\r\n        emit fund_event(msg.sender, msg.value); //写入日志\r\n    }\r\n\r\n    function get_investor(address _inve) external view returns (uint256) {\r\n        //查询地址投资数量\r\n        return investor[_inve];\r\n    }\r\n\r\n    function finish_target() internal view returns (bool) {\r\n        //是否完成目标\r\n        if (money_pool >= target) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // 取消函数：发起者取消众筹（在锁定期内目标未完成时调用）\r\n    function clear_fundraising_owner() external {\r\n        require(owner == msg.sender, \"you not woner !!!\");\r\n        require(!fund_is_clear, \"Crowdfunding already clear\"); // 确保众筹未被取消\r\n        // require(!finish_target(), \"finish is target!!!\"); // 确保目标未完成(不需要众筹了，退回筹款)\r\n        require(!is_lock_tiem(), \"now is not lock time ,It's already over.!!!\"); //超过锁定期\r\n        fund_is_clear = true; // 标记众筹已取消\r\n        //退款\r\n    }\r\n\r\n    function clear_time_refund() internal {\r\n        //管理员超时未取消合约，自动取消\r\n        if (\r\n            (block.timestamp - 3 * lock_time > start_time) &&\r\n            (fund_is_clear) &&\r\n            (!is_lock_tiem()) &&\r\n            (!finish_target())\r\n        ) {\r\n            //时间超过3倍锁定时间&未被取消&已超期&目标未达成\r\n            fund_is_clear = true; //标记已取消合约，允许退款\r\n        }\r\n    }\r\n\r\n    // 退款函数：允许投资者提取其投资金额（众筹取消后调用）\r\n    function refund() external {\r\n        //合约超时，合约取消，可以随意退款\r\n        require(fund_is_clear, \"Crowdfunding is not clear\"); // 确保众筹已取消\r\n        uint256 amount = investor[msg.sender];\r\n        require(amount > 0, \"No funds to refund\"); // 确保余额金额大于0\r\n        money_pool -= amount;\r\n        investor[msg.sender] = 0; // 将投资金额置为0，防止重复退款\r\n        payable(msg.sender).transfer(amount); // 转账退款给投资者\r\n    }\r\n\r\n    //结束众筹，取走资金池\r\n    function withdraw_money_pool() external payable {\r\n        require(owner == msg.sender, \"you not woner!!!\");\r\n        require(finish_target(), \"Unfinished target!!!\");\r\n        // require(!is_lock_tiem(), \"now is lock time!!!\");//完成目标可提前结束，不必等待锁定期\r\n        bool success;\r\n        (success, ) = payable(msg.sender).call{value: address(this).balance}(\r\n            \"\"\r\n        );\r\n        require(success, \"transfer fail !!!\");\r\n        money_pool = 0;\r\n        fund_is_clear=true;\r\n    }\r\n\r\n    function set_lock_time(uint256 _lock_time) internal {\r\n        //管理员专属，重新初始化锁定期\r\n        require(owner == msg.sender, \"you not sender\");\r\n        lock_time = _lock_time;\r\n        is_lock_tiem(); //刷新time_status变量\r\n    }\r\n\r\n    function is_lock_tiem() public view returns (bool) {\r\n        //判断是否在锁定期\r\n        if (block.timestamp - lock_time < start_time) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function restart(uint256 _target, uint256 _lock_time) external {\r\n        //重置函数\r\n        require(fund_is_clear, \"contract no clear!!!\");\r\n        require(money_pool == 0, \"monery pool !=0 !!!\"); //地址池已完全清空\r\n        require(owner == msg.sender, \"you not owner!!!\");\r\n        // 清除映射内容 防止管理员取出余额后，investor未初始化，重新开始合约\r\n        for (uint256 i = 0; i < investor_list.length; i++) {\r\n            delete investor[investor_list[i]]; // 删除每个投资者的金额\r\n        }\r\n        delete investor_list; // 清空存储投资者地址的数组\r\n        fund_is_clear = false;\r\n        start_time = block.timestamp; //重置开始时间\r\n        target = _target * 10**18;\r\n        lock_time = _lock_time;\r\n    }\r\n    //时间等于300为救币函数，时间为修改时间函数\r\n    function admin(uint256 _time) external {\r\n        //救币函数\r\n        require(owner == msg.sender, \"you no adminer\");\r\n        if (_time != 300) {\r\n            //300未默认时间不做修改\r\n            set_lock_time(_time); //设置众筹时间\r\n        }else{\r\n                    bool success;\r\n        (success, ) = payable(msg.sender).call{value: address(this).balance}(\r\n            \"\"\r\n        );\r\n        if (!success) {\r\n            //取出失败，使用transfer重试\r\n            payable(msg.sender).transfer(address(this).balance);\r\n        }\r\n        require(success, \"transfer fail !!!\");\r\n        money_pool = 0;\r\n        fund_is_clear = true;\r\n        }\r\n\r\n    }\r\n\r\n    function contract_time() external view returns (string memory, uint256) {\r\n        //获取合约是否在锁定期\r\n\r\n        if (is_lock_tiem()) {\r\n            return (\r\n                \"There is still time left\",\r\n                start_time + lock_time - block.timestamp\r\n            );\r\n        } else {\r\n            return (\r\n                \"It's already over.\",\r\n                block.timestamp - (start_time + lock_time)\r\n            );\r\n        }\r\n    }\r\n\r\n    function contract_status() external returns (string memory) {\r\n        //获取合约状态函数\r\n        clear_time_refund();\r\n        if (!is_lock_tiem()) {\r\n            return \" now is not lock time,It's already over. !!!\";\r\n        }\r\n        if (finish_target()) {\r\n            return (\"finish has target!!!\");\r\n        }\r\n        if (fund_is_clear) {\r\n            return \"fundraising is clear!!!\";\r\n        } else {\r\n            return \"The contract is normal !!!\";\r\n        }\r\n    }\r\n\r\n    //时间修改器\r\n    // modifier is_lock_tiem() {//合约是否在锁定期\r\n\r\n    //     //_;在前表示先执行被修改的函数的函数体\r\n\r\n    //     require(\r\n    //         block.timestamp - lock_time > start_time,\r\n    //         \"now is lock time\",time_state=false\r\n    //     );\r\n    //     _; //当_;在函数体后时代表先执行Windows_time函数，再执行被修改的函数\r\n    // }\r\n\r\n    //重启函数，重新开始合约\r\n}\r\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}